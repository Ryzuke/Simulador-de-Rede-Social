# -*- coding: utf-8 -*-
"""Projeto I.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1EVH8qMGcsPoHghSSqn6h4nQNNfGG4u2k
"""

import collections

class Usuario:
  """ Representa um usuário da rede social, onde ele tem 3 atributos:
  - id_usuario: Id imutável utilizado para acessar o usuário
  - nome_usuario: Nome do "perfil" do usuário, como ele será visto pelos outros usuários
  - email_usuario: Email simples do usuário
  """
  def __init__(self, id_usuario, nome_usuario, email_usuario):
    self.id_usuario = id_usuario
    self.nome_usuario = nome_usuario
    self.email_usuario = email_usuario

    self.pilha_acoes = [] #Pilha para armazenar as ações do usuário
    self.deque_notificacoes = collections.deque() #Deque que controla as notificações do usuário


  #Função para alteração do nome do usuário
  def mudarNomeUsuario(self, novo_nome):
    self.nome_usuario = novo_nome

class Post:
  """ Representa os posts da rede social, contendo 3 atributos:
  - id_post: Id único e imutável de cada post criado
  - texto: Conteúdo em texto do post
  - Autor: Usuário que criou o post e que vai receber as notificações de cada curtida
  """
  def __init__(self, id_post, texto, autor):
    self.id_post = id_post
    self.texto = texto
    self.autor = autor
    self.likes = 0  #Contador de likes do post
    self.visivel = True #Boolean para definir se o post foi ou não removido

  #Funções para adicionar e remover curtidas do post, para se ter um melhor controle
  def adicionarCurtidas(self):
    self.likes += 1

  def removerCurtidas(self):
    if self.likes > 0:
      self.likes -= 1

class RedeSocial:
  """ Classe que gerencia todas as funções primárias do código.
  Utiliza composição para realizar as interações entre as 3 classes
  """
  def __init__(self):
    self.lista_usuarios = [] #Lista de usuários inicialmente vazia. Será preenchida a medida que se cadastra novos usuários
    self.deque_feed_global = collections.deque() #Deque que será armazenado todos os posts feitos. Servirá de feed geral onde todos os posts aparecerão em ordem
    #Id de usuário e de post começa em 1 e serão incrementados a medida que novos usuários ou posts são criados.
    #Garantir que cada id seja unico
    self.proximo_id_usuarios = 1
    self.proximo_id_posts = 1


  def cadastrarUsuario(self, nome, email):
    #Criação de um objeto Usuario. Adicionando o novo usuário na lista de usuários e incrementando o id de usuários
    #Para quando o próximo usuário for cadastrado ja ser um novo id
    novo_usuario = Usuario(self.proximo_id_usuarios, nome, email)
    self.lista_usuarios.append(novo_usuario)
    print(f"Usuário '{nome}', de id '{self.proximo_id_usuarios}' cadastrado com sucesso!")
    self.proximo_id_usuarios += 1
    return


  def criarPost(self, id_usuario, texto):
    #Verificando se existir um usuário com o id fornecido
    autor = self.buscarUsuarioPorId(id_usuario)
    if autor:
      novo_post = Post(self.proximo_id_posts, texto, autor)
      #Após criar um novo objeto do tipo post, ele é adicionado ao deque de feed global e incremento o valor do id de posts
      #Já preparando para o próximo
      self.deque_feed_global.appendleft(novo_post)
      self.proximo_id_posts += 1

      #Criando uma tupla de ações para armazenar na pilha de ações
      #Essa tupla será usada para verificar a ação que será desfeita na função de desfazer ações
      acao = ('criou_post', novo_post.id_post)
      autor.pilha_acoes.append(acao)
      print(f"Post '{texto}', do usuário {autor.nome_usuario} foi postado com sucesso!")
      return
    else:
      print(f"Erro! Usuário {id_usuario} não existe")
      return None

  def curtirPost(self, id_post, id_usuario_que_curtiu):
    #Para curtir o post primeiro se busca o post que será curtido e depois o usuário que realizará a ação
    post = self.buscarPostPorId(id_post)

    usuario_que_curtiu = self.buscarUsuarioPorId(id_usuario_que_curtiu)

    if usuario_que_curtiu and post:
      #Se ambos forem encontrados e válidos, o autor do post receberá uma notificação que seu post foi curtido
      #Então quando ele quiser ver as notificações, irá aparecer no topo a curtida mais recente, por isso o appendleft no deque
      if post.visivel:
        autor_original = post.autor
        notificacao = f"O usuário {usuario_que_curtiu.nome_usuario} curtiu seu post!"
        autor_original.deque_notificacoes.appendleft(notificacao)

        #Tupla de ação sendo criada para identificação da nova ação e no fim adicionando a curtida no post por meio da função criada na própria classe Post
        nova_acao = ('curtiu_post', post.id_post)
        usuario_que_curtiu.pilha_acoes.append(nova_acao)

        post.adicionarCurtidas()

        print("Post curtido e notificação enviada!")
      else:
        print("O post não existe mais")

    else:
      print("ERRO: Usuario ou post não encontrado!")

  def removerPost(self, id_post):
    #Busca o post por id, se retornar true, muda o status dele para False, resultando em um soft delete
    post = self.buscarPostPorId(id_post)

    if not post:
      print("O post procurado não existe!")

    else:
      post.visivel = False
      print(f"Post {id_post} foi removido com sucesso")

  def desfazerAcao(self, usuario_id):
    #Busca pelo usuário que será removida a última ação
    usuario = self.buscarUsuarioPorId(usuario_id)
    #Se o usuário não existe ou ele não tem nenhuma ação realizada ainda, fazer nada
    if not usuario:
      print(f"Usuario de id {usuario_id} não foi encontrado")
      return

    if not usuario.pilha_acoes:
      print(f"Usuario de id {usuario_id} não realizou nenhuma acao")
      return
    #Removendo a última ação e pegando as referências para comparação no if
    ultima_acao = usuario.pilha_acoes.pop()
    tipo_acao, id_referencia = ultima_acao

    print(f"A acao {tipo_acao} de id {id_referencia} será removida")

    if tipo_acao == 'criou_post':
      #Se a última ação foi criar um post, então primeiro se acha o post feito.

      remover_post = self.buscarPostPorId(id_referencia)
      #Se o post existe, ele é removido do deque do feed global
      if remover_post:
        post.visivel = False
        print(f"Ação desfeita com sucesso. O post foi removido!")
      else:
        print(f"O post a ser removido não foi encontrado no feed")

    elif tipo_acao == 'alterar_nome':
      #Se a última ação foi alterar o nome, se procura o id do usuário. Se existir, não acontece nada pois não é possível recuperar um nome antigo
      desfazer_alteracao_nome = self.buscarUsuarioPorId(id_referencia)

      if desfazer_alteracao_nome:
        print(f"A última ação foi alterar um nome, então ela não pode ser desfeita.")

      else:
        print(f"ERRO: O usuário de id {id_referencia} não foi encontrado no sistema!")

    elif tipo_acao == 'curtiu_post':
      #Por fim, se a última ação foi curtir um post, se busca primeiro o post curtido
      desfazer_curtida = self.buscarPostPorId(id_referencia)
      #Se ele existir, a curtida é removida por meio da função de remover curtidas implementada na classe Post
      if desfazer_curtida:
        desfazer_curtida.removerCurtidas()
        print("A curtida foi removida do post!")
      else:
        print("Não foi possivel localizar o post!")

  def alterarNomeUsuario(self, usuario_id, novo_nome):
    usuario_para_alterar = self.buscarUsuarioPorId(usuario_id)
    #Depois de procurar o usuário que vai ter o nome alterado, verifica se ele existe
    if usuario_para_alterar:

      #O nome do usuário é alterado por meio da função alterar nome implementada na classe Usuario
      usuario_para_alterar.mudarNomeUsuario(novo_nome)
      print(f"Nome do usuário {usuario_id} foi alterado com sucesso para '{novo_nome}' ")

      #Ação realizada e inserida na pilha de ações do usuário
      nova_acao = ('alterar_nome', usuario_para_alterar.id_usuario)
      usuario_para_alterar.pilha_acoes.append(nova_acao)
      return True

    else:
      print(f"Usuário com id {usuario_id} não existe")
      return False

  def verificarFeedGlobal(self):
    print("----- FEED GLOBAL -----")
    #Loop para verificar o feed global em ordem de post mais recente
    if not self.deque_feed_global:
      print("Nenhum post feito ainda")
      return
    #Verificando pra caso o post seja deletado ele só printar os posts ainda existentes
    for post in self.deque_feed_global:
      if post.visivel:
        print("--------------")
        print(f"Post ID: {post.id_post} | Autor: {post.autor.nome_usuario}")
        print(f"Texto: {post.texto}")
        print(f"Número de likes: {post.likes}")
        print("--------------")


  def notificacaoDoUsuario(self, usuario_id):
    usuario = self.buscarUsuarioPorId(usuario_id)
    #Após a busca do usuário para ver as notificações, se ele existir é printada as notificações dele
    if usuario:
      print(f"Notificações de {usuario.nome_usuario} ")
      if not usuario.deque_notificacoes:
        #Caso o usuário não possua notificações, não faz nada
        print(f"Usuário {usuario.nome_usuario} não tem notificações")
        return

      for notificacao in usuario.deque_notificacoes:
        print(f"- {notificacao}")
    else:
      print(f"Erro: usuário não encontrado")

  def merge_sort(self, lista_de_posts):
    #Função recursiva do merge onde é realizada a ordenação da lista
    if len(lista_de_posts) <= 1:
      return lista_de_posts

    #Dividir: A lista é dividida em duas metades, esquerda e direita

    meio = len(lista_de_posts) // 2
    metade_esquerda = lista_de_posts[:meio]
    metade_direita = lista_de_posts[meio:]

    #Conquistar: Chamada recursiva para ordenar as duas metades

    metade_esquerda = self.merge_sort(metade_esquerda)
    metade_direita = self.merge_sort(metade_direita)

    #Junção das metades ordenadas

    return self.merge(metade_esquerda, metade_direita)


  def merge(self, left, right):
    #Função auxiliar para comparar os elementos da lista e mesclar em ordem
    merged = []
    left_index, right_index = 0, 0
    #Comparação dos elementos onde em caso de empate no primeiro item, se verifica o segundo

    while left_index < len(left) and right_index < len(right):
      if (left[left_index].likes, left[left_index].id_post) > (right[right_index].likes, right[right_index].id_post):
        merged.append(left[left_index])
        left_index += 1
      else:
        merged.append(right[right_index])
        right_index += 1

    #Adiciona os elementos restantes de qualquer uma das listas
    merged.extend(left[left_index: ])
    merged.extend(right[right_index: ])
    return merged

  def verFeedEmAlta(self):
    #Função onde transformo o deque do feed global e o ordeno em ordem decrescente de likes utilizando o merge_sort
    temp_list = list(self.deque_feed_global)
    lista_ordenada = self.merge_sort(temp_list)

    if not temp_list:
      print("Não existe post no feed global")
      return

    for post in lista_ordenada:
      if post.visivel:
        print("-------- FEED EM ALTA -------")
        print(f"LIKES: {post.likes} | Post ID: {post.id_post} | Autor: @{post.autor.nome_usuario}")
        print(f"Texto: {post.texto}")
        print("----------------------------------------")

  #Funções de buscar usuario por id e buscar post por id
  def buscarUsuarioPorId(self, id_usuario):
    #Busca de usuário por ID utilizando busca binária
    #Funciona bem pois a lista está ordenada por ID
    baixo = 0
    alto = len(self.lista_usuarios) - 1

    while baixo <= alto:
        meio = (alto + baixo) // 2
        usuario_meio = self.lista_usuarios[meio]

        if usuario_meio.id_usuario < id_usuario:
            baixo = meio + 1

        elif usuario_meio.id_usuario > id_usuario:
            alto = meio - 1

        else:
            return usuario_meio

    return None

  def buscarPostPorId(self, id_post):
    for p in self.deque_feed_global:
      if p.id_post == id_post:
        return p
    return None

def sorting(arr):
  n = len(arr)
  for i in range(n):
    current = arr[i]
    j = i - 1
    while j >= 0 and current < arr[j]:
      arr[j] = arr[j + 1]
      j -= 1
    current = arr[j + 1]

#Testes
print("="*50)
print("INICIANDO DEMONSTRAÇÃO DO SISTEMA...")
print("="*50)

social = RedeSocial()
social.cadastrarUsuario("Diego", "Diego@hotmail")
social.cadastrarUsuario("Pedro", "Pedro@hotmail")
social.criarPost(1, "Testando a criação de um post")
social.criarPost(2, "Testando a criação de um post")
social.verificarFeedGlobal()
social.curtirPost(1, 2)
social.verificarFeedGlobal()
social.alterarNomeUsuario(1, "Diego Amaral")
social.desfazerAcao(1)
social.curtirPost(1, 1)
social.notificacaoDoUsuario(1)
social.criarPost(2, "Criando um segundo post para teste de ordem")
social.verificarFeedGlobal()
print("-----")
social.curtirPost(1, 2)
social.notificacaoDoUsuario(1)
social.desfazerAcao(2)
social.verificarFeedGlobal()
social.curtirPost(2, 1)
social.curtirPost(2, 2)
print("---------")
social.verFeedEmAlta()
social.removerPost(2)
social.verFeedEmAlta()
social.curtirPost(2, 1)
social.criarPost(1, "Post pra ser deletado")
social.removerPost(4)
social.verificarFeedGlobal()
social.curtirPost(2, 1)

print("\n" + "="*50)
print("FIM DA DEMONSTRAÇÃO AUTOMATIZADA.")
print("O objeto 'RedeSocial' está populado e pronto para uso interativo.")
print("="*50)

print("\n" + "="*50)
print("INICIANDO SESSÃO INTERATIVA...")
print("A rede social já contém os usuários e posts da demonstração anterior.")
print("="*50)

while True:
    print("\n--- MENU DA REDE SOCIAL ---")
    print("1. Cadastrar Novo Usuário")
    print("2. Criar Novo Post")
    print("3. Curtir um Post")
    print("4. Alterar Nome de Usuário")
    print("5. Remover um Post (Soft Delete)")
    print("6. Desfazer Última Ação")
    print("7. Ver Feed Global")
    print("8. Ver Feed em Alta (Mais Curtidos)")
    print("9. Ver Notificações de um Usuário")
    print("0. Sair")

    escolha = input("Digite o número da sua escolha: ")

    if escolha == '1':
        # --- Cadastrar Usuário ---
        nome = input("Digite o nome do novo usuário: ")
        email = input("Digite o email do novo usuário: ")
        social.cadastrarUsuario(nome, email)

    elif escolha == '2':
        # --- Criar Post ---
        try:
            id_usuario = int(input("Digite o ID do usuário que está postando: "))
            texto = input("Digite o texto do post: ")
            social.criarPost(id_usuario, texto)
        except ValueError:
            print("ID inválido. Por favor, digite um número.")

    elif escolha == '3':
        # --- Curtir Post ---
        try:
            id_post = int(input("Digite o ID do post para curtir: "))
            id_usuario = int(input("Digite o seu ID de usuário: "))
            social.curtirPost(id_post, id_usuario)
        except ValueError:
            print("ID inválido. Por favor, digite um número válido.")

    elif escolha == '4':
      # --- Alterar nome do usuário ---
      try:
          id_usuario = int(input("Digite o ID do usuário que quer alterar o nome: "))
          novo_nome = input("Digite o novo nome: ")
          social.alterarNomeUsuario(id_usuario, novo_nome)
      except ValueError:
          print("ID inválido. Por favor, digite um número válido.")

    elif escolha == '5':
      # --- Remover Post ---
      try:
        id_post = int(input("Digite o ID do post para remover: "))
        social.removerPost(id_post)
      except ValueError:
          print("ID inválido. Por favor, digite um número válido.")

    elif escolha == '6':
      # --- Desfazer última ação ---
      try:
        usuario_id = int(input("Digite o ID do usuário que quer remover a última ação"))
        social.desfazerAcao(usuario_id)
      except ValueError:
          print("ID inválido. Por favor, digite um número válido")

    # ... (adicione os 'elif' para as outras opções: 4, 5, 6, etc.) ...

    elif escolha == '7':
      #--- Ver feed global ---
        social.verificarFeedGlobal()

    elif escolha == '8':
      #--- Ver feed em alta ---
        social.verFeedEmAlta()

    elif escolha == '9':
      #--- Notificação do usuário ---
        try:
            id_usuario = int(input("Digite o ID do usuário para ver as notificações: "))
            social.notificacaoDoUsuario(id_usuario)
        except ValueError:
            print("ID inválido. Por favor, digite um número.")


    elif escolha == '0':
        # --- Sair e Salvar ---
        print("Saindo do programa...")
        break # Quebra o loop 'while True' e encerra o programa

    else:
        print("Opção inválida! Por favor, tente novamente.")